\documentclass{article}
 
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[amssymb]{amssymb}
\usepackage[tabto]{tabto}

\makeatletter
\renewcommand{\@seccntformat}[1] {
    \ifcsname prefix@#1\endcsname
        \csname prefix@#1\endcsname
    \else
        \csname the#1\endcsname\quad
    \fi}
\newcommand\prefix@section{}
\makeatother

\makeatletter
\renewcommand{\@subseccntformat}[1] {
    \ifcsname prefix@#1\endcsname
        \csname prefix@#1\endcsname
    \else
        \csname the#1\endcsname\quad
    \fi}
\newcommand\prefix@subsection{}
\makeatother
 
 
\begin{document}


\section {Определения}

\subsection{Путь}
Последовательность (кортеж) вершин и ребер над графом \(G = (V, E)\) вида: (\(v_1\), \(e_1\), \(v_2\), \(e_2\), ...), где \(v_i \in V\), \(e_i \in E\), причем \( e_i = (v_i, v_i_+_1)\) в случае ориентированного графа и \(e_i = \{v_i, v_i_+_1\}\) в случае неориентированного. Обозначается \(p: v_1 \rightsquigarrow v_n\), где \(n = |p|/2 + 1/2\).

\subsection{Простой путь, или цепь}
Путь \(sp\) простой и называется цепью, когда \(\forall i\), \(j  \in \{1, n - 1\}\): \(e_i \neq e_j\). \(e_i, e_j \in sp\).

\subsection{Простая цепь}
Цепь \(sc\) называется простой, когда \(\forall i\), \(j \in \{1, n\}\): \(v_i \neq v_j\). \(v_i, v_j \in sc\).

\subsection{Цикл}
Путь \(cc\) называется циклом, когда \(v_1 = v_n\).

\subsection{Реберно-простой цикл}
Цепь \(escc\) называется реберно-простым циклом, когда \(v_1 = v_n\).

\subsection{Вершинно-простой цикл}
Цепь \(vscc\) называется вершинно-простым циклом, когда \(\forall i \in \{1, n\}\), \(j \in \{1, n - 1\}\): \(v_i \neq v_j\), и \(v_1 = v_n\). \(v_i, v_j \in vscc\).

\subsection{Простой цикл}
Цикл \(scc\) называется простым циклом, когда он является реберно-простым, а также и вершинно-простым.
\newpage


\section {Леммы о путях}

\subsection {Лемма 1}

Если вершины \(v\) и \(u\) соединяет путь \(p: v \rightsquigarrow u\), то существует простой путь (цепь) \(sp: v \rightsquigarrow u\).\newline

\(\square\)
Докажем это утверждение, построив простой путь \(sp: v \rightsquigarrow u\) по индукции.\newline

База: первое ребро в простом пути \(sp\) - то же, что и в \(p\).\newline

Переход: проходим по ребрам пути \(p\), просматривая одно ребро на каждой итерации индукции. Пусть последнее рассмотренное ребро в \(p\) - \(e_i\), а последнее добавленное в простой путь \(sp\) ребро - \(e_j\).\newline
Рассмотрим два случая:\newline
\tab\tab Если следующее за \(e_i\) в \(p\) ребро еще не было добавлено в \(sp\), то добавляем это ребро в \(sp\).\newline
\tab\tab Иначе, в \(sp\) образовался цикл. Пусть ребро \(e_i\) было встречено в \(sp\) под индексом \(j-k\). Тогда очевидно, что нам необходимо удалить все ребра после \(e_j_-_k\), удалив тем самым "реберный цикл" длиной k. После этого, (не добавляя \(e_i\) в \(sp\)), продолжить индукцию.\newline

Очевидны следующие 3 утверждения:\newline
\tab\tab Если путь конечен - то \(sp\) тоже конечен (в случае бесконечных путей нужна трансфинитная индукция, либо аксиома выбора.)\newline
\tab\tab Путь \(sp\) простой. Ну действительно, на каждом шаге мы добавляли ребро, которое отсутствовало в пути до этого, либо не добавляли его вообще.
\tab\tab Путь \(sp\) "неразрывен" и соединяет \(v\) с \(u\). На каждом шаге мы добавляем ребро, которое инцидентно конечной вершине предыдущего, либо удаляем цикл, что вообще ничего не портит, так как на следующем шаге мы опять добавим ребро, инцидентное последнему неудаленному в \(sp\), либо индукция завершится.
\(\blacksquare\)
\newline\newline\newline

\subsection {Лемма 2}

Если вершины \(v\) и \(u\) соединяет цепь \(c: v \rightsquigarrow u\), то существует простая цепь \(sc: v \rightsquigarrow u\).\newline

\(\square\) Эта лемма доказывается аналогично предыдущей, однако индукия проводится не по ребрам, а по вершинам!
\(\blacksquare\)
\newpage
 
 
\section {Вершинная двусвязность и точки сочленения}

\subsection {Определение}
Ребра \(e_1 = (v_1, u_1)\) и \(e_2 = (u_2, u_2)\), \(e_1, e_2 \in E\) некоторого графа \(G = (V, E)\) наз-ся реберно-двусвязными, если \(\exists\) вершинно-независимые (непересекающиеся) пути \(p_1: v_1 \rightsquigarrow v_2\), \(p_2: u_1 \rightsquigarrow u_2\).
\newline

\subsection {Отношение вершинной двусвязности}
Вершинная двусвязность - отношение эквивалентности над \(E^2\) в графе \(G = (V, E)\). \newline

\(\square\)
    Рефлексивность: имеет два пустых, а следовательно, непересекающихся вершенно пути.\newline
    \tab\tabСимметричность: следует из симметричного определения.\newline
    \tab\tabТранзитивность: хотим доказать следующее утверждение:\newline
    \(e_1 = (v_1, u_1), e_2 = (v_2, u_2)\) и \(e_2 = (v_2, u_2), e_3 = (v_3, u_3)\) реберно двусвязны \Rightarrow \(e_1, e_3\) тоже.\newline
    Пока что далее доказывать не буду - док-во (хоть и не точное) есть на викиконспектах, но если потребуется большая точность, я это проделаю.
\(\blacksquare\)
\newline

\subsection {Блок}
Блоком, или компонентой вершинной двусвязности графа, называют его подграф, множество ребер которого — класс эквивалентности вершинной двусвязности, а множество вершин — множество всевозможных концов ребер из соответствующего класса.\newline\newline

\subsection {Точка сочленения. Определения}
\tab 1) Вершина \(v\) наз-ся точкой сочленения, если она принадлежит нескольким блокам. \newline

2) Вершина  \(v\) наз-ся точкой сочленения, если при ее удалении, вместе со всеми инцидентными ребрами из графа кол-во компонент связности возрастает.\newline

3) Вершина  \(v\) наз-ся точкой сочленения, если существуют такие вершины \(u\) и \(w\), отличные от \(v\), что \(v\) принадлежит любому простму пути \(u \rightsquigarrow w\).\newline

4) Вершина  \(v\) наз-ся точкой сочленения, если существует такое разбиение множества \(V/\{v\}\) на мн-ва \(U\) и \(W\), что \(\forall u \in U\), \(w \in W\): \(\forall p: u \rightsquigarrow w\), \(v \in p\).\newline

\subsection {Теорема 1}
Все четыре определения эквивалентны.\newline
\(\square\)
Док-ва на викиконспектах.
\(\blacksquare\)

\subsection {Теорема 2}
Пусть \(G = (V, E)\) - cвязный неориентированный граф с \(|V| \geq 3\). Тогда следующие 7 утверждений эквиваленты:\newline
1) G не содержит точек сочленения.\newline
2) Любые две вершины графа G принадлежат некоторому общему простому циклу.\newline
3) Любая вершина и любое ребро графа G принадлежат некоторому общему простому циклу.\newline
4) Любые два ребра графа G принадлежат некоторому общему простому циклу.\newline
5) Для любых двух вершин и любого ребра графа G существует простая цепь, соединяющая эти вершины и включающая данное ребро.\newline
6) Для любых трех различных вершин графа G существует простая цепь, соединяющая две из них и проходящая через третью.\newline
7) Для каждых трех различных вершин графа G существует простая цепь, соединяющая две из них и не проходящая через третью.\newline\newline
\(\square\) \tab \(\underline{1 \Rightarrow 4}\)\newline
\tab\tab Так как граф не содержит точек сочленения, каждая вершина принадлежит либо одному блоку, либо является изолированной, но так как граф по условидю связен, она не может быть изолированый. Значит, каждая вершина принадлежит одному блоку, и, в силу связности графа, этот блок один и тот же для любой вершины (Если бы существовали два блока, то в силу связности, они бы пересекались в некоторой точке сочленения, которые отсутствуют). Значит весь граф G - блок.\newline
\tab\tab По определению блока и отношения вершинной двуствязности: \(\forall e_1, e_2 \in E\) \((e_1 = \{v_1, u_1\}, e_2 = \{v_2, u_2\} \wedge v_1, v_2, u_1, u_2 \in V)\) \(\exists\) вершинно-независимые пути \(p_1: v_1 \rightsquigarrow v_2\) и \(p_2: u_1 \rightsquigarrow u_2\). По Лемме 1 о путях, существуют простые пути \(sp_1: v_1 \rightsquigarrow v_2\) и \(sp_2: u_1 \rightsquigarrow u_2\). Значит, по Лемме 2 о путях, существуют простые цепи \(sc_1: v_1 \rightsquigarrow v_1\) и \(sc_2: u_1 \rightsquigarrow u_2\). Причем, так как \(p_1\) и \(p_2\) вершинно-независимы, \(sc_1\) и \(sc_2\) тоже. \newline
\tab\tab Построим путь scc = \(\overline{e_1} \rightsquigarrow sc_1 \rightsquigarrow e_2 \rightsquigarrow \overline{sc_2}\). Очевидно,  \(scc\) - вершинно-простой цикл (по определению). также, все ребра в нем разлины, поэтому он и реберно-простой. Значит, по определению, он простой.\newline
\tab\tab В случаях, когда ребра \(e_1\) и \(e_2\) имеют одну общую вершину, одна из простых цепей \(sc_1\), \(sc_2\) будет содержать только одну вершину, следовательно, будет иметь нулевую длину, но это ничего не портит, так как все равно \(scc\) будет вершинно-простым циклом. Аналогичные рассуждения проведем и в случае двух разлиных, но параллельных ребер.
\tab\tab Но вот в случае \(e_1 = e_2\) так рассуждать не выйдет, так как цикл \(scc\) будет не вершинно-простой, но не реберно-простой! Поэтому, возьмем какое-нибудь другое, отличное от \(e_1 = e_2\) ребро \(e'\) (такое найдется, в силу того, что у любого связного графа с \(|V| \geq 3 : |E| \geq 2\). По доказанному выше, найдется простой цикл, содержащий \(e_1 = e_2\) и \(e'\), значит \(e_1\) и \(e_2\) лежат на простом цикле и в этом случае.\newline\newline
\tab \(\underline{4 \Rightarrow 3}\)\newline
Очевидно. Частный случай.\newline\newline
\tab \(\underline{3 \Rightarrow 2}\)\newline
Очевидно. Частный случай.\newline\newline
\tab \(\underline{2 \Rightarrow 1}\)\newline
\tab\tab Предположим, что даже если каждые две вершины лежат на простом цикле, все равно может существовать точка сочленения \(v\). Итак, если при удалении вершины \(v\) количество компонент связности возрастает, то \(v\) - точка сочленения (по определению 2). Очевидно, что при удалении вершины \(v\) необходимо доказать лишь то, что все инцидентные вершины \(u_i\) будут соединены, так как только они могли отсоединиться друг от друга, ведь остальной подграф не изменился.\newline
\tab\tab Итак, предположим, что вершины \(u_i\) и \(u_j\) после удаления \(v\) не соединяет никакой путь, и они попали в разные компоненты связности. Но ведь до удаления \(v\) они лежали на простом цикле! Правда, этот простой цикл мог содерджать \(v\) на одной из своих подцепей \(u_i \rightsquigarrow u_j\) или \(u_j \rightsquigarrow u_i\), но тогда разрушиться могла только одна из этих двух цепей, а вторая осталась неизменной, значит, даже после удаления \(v\), \(u_i\) и \(u_j\) соединяет (как минимум одна) простая цепь, а значит и путь. В силу произвольности выбора \(u_i\) и \(u_j\), любые две инцидентные к \(v\) вершины, даже после ее удаления останутся связны (по определению). Значит весь граф останется связным. Противоречие: \(v\) - не точка сочленения (по определению 2). Значит, в силу произвольности выбора \(v\) - она не точка сочленения.\newline\newline
\tab \(\underline{4 \Rightarrow 5}\)\newline
\tab\tab Рассмотрим три ребра \(e_1 = \{v_1, u_1\}\), \(e_2 = \{v_2, u_2\}\), \(e = \{v, u\}\). Пусть ребра \(e_1, e\) лежат на простом цикле \(scc_1\), а ребра \(e_2, e\) - на \(scc_2\).\newline
\tab\tab Пусть, при движении по циклу \(scc_2\) от \(v_2\) до \(v\), встретилась вершина \(w\), которая принадлежит и \(scc_1\) и \(scc_2\). Тогда далее пойдем уже по циклу \(scc_1\), причем так, чтобы пройти от \(w\) до \(u_1\) через \(e\) (это сделать можно, выбрав подцепь цикла \(scc_1\), содержащую \(e\)). Очевидно, что мы построили простую цепь \(v_2 \rightsquigarrow u_1\) при таком обходе, которая также содержит \(e\). В силу произвольности \(u_1\), \(v_2\), \(e\), это можно сделать для любых двух вершин и любого ребра.\newline\newline
\tab \(\underline{5 \Rightarrow 6}\)\newline
\tab\tab Очевидно. Частный случай.\newline\newline
\tab \(\underline{6 \Rightarrow 7}\)\newline
\tab\tab Пусть простая цепь \(sc: v \rightsquigarrow u\) проходит через \(w\). Тогда, взяв простую подцепь \(v \rightsquigarrow w\) простой цепи \(sc\), получим простую цепь \(v \rightsquigarrow w\), не содержащую \(u\).\newline\newline
\tab \(\underline{7 \Rightarrow 1}\)\newline
\tab\tab Докажем от противного что в \(G\) нет точек сочленения. Итак, предположим обратное. Пусть \(v\) - точка сочленения. Но ведь \(\exists\) простая цепь \(u \rightsquigarrow w\) не содержащая \(v\), а это значит, что условие: \(\exists u, w \in V\)  такие что, \forall простой цепи \(sc: u \rightsquigarrow w\), \(v \in sc\) не выполнено. Противоречие - \(v\) - не точка сочленения (по определению 3). Значит в \(G\) нет точек сочленения.
\(\blacksquare\)



\end{document}